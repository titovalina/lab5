# Титова Алина ИТ-7 Лабораторная №5 (1 вариант)

# Задание 1.
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
* Имеет числитель: целое число
* Имеет знаменатель: целое число
* Дробь может быть создана с указанием числителя и знаменателя
* Может вернуть строковое представление вида “числитель/знаменатель”
* Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
* Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
<img width="453" height="148" alt="image" src="https://github.com/user-attachments/assets/3b81581f-af12-49b6-9e6c-5ea67c3fa30a" />

### Алгоритм решения
1. Объявить свойства:
* numerator
* denominator
* cachedValue
* boolean flag — есть ли кэш
2. При изменении числителя/знаменателя:
* сбрасывать кэш
3. Метод toDouble():
* если кэш есть → вернуть значение
* иначе:
  * вычислить numerator / denominator
  * сохранить в кэш
  * вернуть результат
4. В equals() сравнить числитель и знаменатель.
5. Не допускать отрицательного знаменателя:
* если пришёл отрицательный, изменить знак у числителя и знаменателя.

# Задание 3.
### Текст задачи
3. Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его упорядоченности.
<img width="629" height="83" alt="image" src="https://github.com/user-attachments/assets/5d074f5e-135b-4b20-a5e6-f357a661a05b" />

### Алгоритм решения
1. Создать новый список R. 
2. Использовать два индекса: i = 0, j = 0. 
3. Пока оба индекса в пределах списков:
* сравнить L1[i] и L2[j]
* меньший → добавить в R
* увеличить соответствующий индекс
4. Добавить оставшиеся элементы L1 или L2. 
5. Вернуть R.

# Задание 4.
### Текст задачи
3. На вход программы подаются сведения о результатах соревнований по школьному многоборью. Многоборье состоит из соревнований по четырем видам спорта, участие в каждом из которых оценивается баллами от 0 до 10 (0 баллов получает ученик, не принимавший участия в соревнованиях по данному виду спорта). Победители определяются по наибольшей сумме набранных баллов. Известно, что общее количество участников соревнований не превосходит 100.
В первой строке вводится количество учеников, принимавших участие в соревнованиях, N. Далее следуют N строк, имеющих следующий формат: <Фамилия><Имя><Баллы>
Здесь <Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не более чем из 15 символов;<Баллы> - строка, содержащая четыре целых числа, разделенных пробелом, соответствующих баллам, полученным на соревнованиях по каждому из четырех видов спорта. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом.
Примеры входных строк:
Иванова Мария 5 8 6 3
Петров Сергей 9 9 5 7
Напишите программу, которая будет выводить на экран фамилии и имена трех лучших участников многоборья. Если среди остальных участников есть ученики, набравшие то же количество баллов, что и один из трех лучших, то их фамилии и имена также следует вывести. При этом имена и фамилии можно выводить в произвольном порядке.
<img width="587" height="209" alt="image" src="https://github.com/user-attachments/assets/6722e923-fc1c-4e3a-b9ef-e1f7936351dd" />

### Алгоритм решения
1. Считать количество участников N.
2. Для каждой строки:
* Разбить строку на фамилию, имя и 4 балла.
* Проверить корректность данных.
* Сохранить в список участников.
3. Посчитать сумму баллов у каждого участника.
4. Отсортировать участников по сумме баллов (убывание).
5. Выбрать первых трёх:
* если у остальных есть такая же сумма, добавить и их.
6. Вывести всех участников, чья сумма ≥ суммы 3-го места.

# Задание 5.
### Текст задачи
7. Файл содержит текст на русском языке. Сколько разных букв встречается в тексте?
<img width="450" height="70" alt="image" src="https://github.com/user-attachments/assets/c886dd70-b971-4da6-a610-6b949168dd75" />

### Алгоритм решения
1. Открыть файл через BufferedReader.
2. Читать его построчно.
3. Каждую строку приводить к нижнему регистру.
4. Проходить по каждому символу.
5. Проверять: является ли буквой русского алфавита:
* 'а' ≤ ch ≤ 'я' или 'ё'
6. Добавлять в Set.
7. По окончании вывести размер Set.

# Задание 6.
### Текст задачи
2. По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить очередь из элементов 1, 2, 3, 3, 2, 1).
<img width="505" height="84" alt="image" src="https://github.com/user-attachments/assets/3e61663a-0010-4b74-ac9b-26c0c7e2dff8" />

### Алгоритм решения
1. Имеется список L.
2. Создать пустую очередь Q.
3. Добавить в очередь все элементы списка L по порядку.
4. Пройти по списку L в обратном порядке:
* добавить каждый элемент в очередь.
5. Вернуть очередь.

# Задание 7.
### Текст задачи
1. Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
* Координата Х: число.
* Координата Y: число.
* Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
* Координата начала: Точка
* Координата конца: Точка
* Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
* Имеет массив Точек, через которые линия проходит.
* Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это результат приведения к строке Точки с номером N
<img width="675" height="74" alt="image" src="https://github.com/user-attachments/assets/0434e330-fb5e-4092-a505-4eacdc6ac4b1" />

### Алгоритм решения


### Текст задачи
2. Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру:
[5:[Вася, Аня], 3:[Петя]]
<img width="525" height="72" alt="image" src="https://github.com/user-attachments/assets/01c628f8-d917-4218-9a7c-b4882c1bac10" />

### Алгоритм решения
1. Считать все строки файла в список.
2. Создать поток строк.
3. Для каждой строки:
* Разбить по ":".
* Левая часть → имя.
* Правая часть → номер (если отсутствует — пропустить строку).
4. Имя преобразовать:
* в нижний регистр
* первую букву сделать заглавной
5. Преобразовать номер в int.
6. Отфильтровать строки без номера.
7. Использовать Collectors.groupingBy():
* ключ: номер
* значение: список имён
8. Вернуть Map<Integer, List<String>>
